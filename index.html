<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æˆ¦ç•¥ã‚¿ãƒ¯ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    #app {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      overflow: hidden;
      max-width: 1500px;
      width: 100%;
    }
    #game-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #game-header h1 {
      font-size: 24px;
      font-weight: bold;
    }
    .stats {
      display: flex;
      gap: 20px;
      font-size: 16px;
    }
    .stat {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .stat-icon {
      font-size: 20px;
    }
    #game-content {
      display: flex;
    }
    #canvas-container {
      position: relative;
      flex: 1;
    }
    canvas {
      display: block;
      background: #2a2a2a;
      cursor: pointer;
    }
    #sidebar {
      width: 300px;
      background: #f8f9fa;
      padding: 20px;
      border-left: 2px solid #e0e0e0;
      max-height: 720px;
      overflow-y: auto;
    }
    .phase-indicator {
      background: #667eea;
      color: white;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
      font-weight: bold;
      margin-bottom: 20px;
      font-size: 14px;
    }
    .phase-indicator.battle {
      background: #f093fb;
    }
    .tower-section h3, .unit-section h3 {
      font-size: 14px;
      color: #666;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .tower-btn, .unit-btn {
      width: 100%;
      padding: 16px;
      margin-bottom: 12px;
      border: 2px solid #ddd;
      border-radius: 8px;
      background: white;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
    }
    .tower-btn:hover:not(:disabled), .unit-btn:hover:not(:disabled) {
      border-color: #667eea;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
      transform: translateY(-2px);
    }
    .tower-btn:disabled, .unit-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .tower-btn.selected {
      border-color: #667eea;
      background: #f0f4ff;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    .tower-btn-title, .unit-btn-title {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .tower-btn-desc, .unit-btn-desc {
      font-size: 12px;
      color: #666;
      line-height: 1.4;
    }
    .start-btn {
      width: 100%;
      padding: 16px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 20px;
    }
    .start-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
    }
    .start-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .info-box {
      background: #e3f2fd;
      border-left: 4px solid #2196f3;
      padding: 12px;
      border-radius: 4px;
      font-size: 13px;
      line-height: 1.6;
      color: #1565c0;
      margin-top: 20px;
    }
    #modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #modal.show {
      display: flex;
    }
    #rush-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #ff6b6b 0%, #ff0000 100%);
      color: white;
      padding: 30px 60px;
      border-radius: 20px;
      font-size: 48px;
      font-weight: bold;
      box-shadow: 0 10px 40px rgba(255, 0, 0, 0.5);
      display: none;
      z-index: 999;
      animation: pulse 0.5s infinite alternate;
    }
    #rush-notification.show {
      display: block;
    }
    @keyframes pulse {
      from { transform: translate(-50%, -50%) scale(1); }
      to { transform: translate(-50%, -50%) scale(1.05); }
    }
    .modal-content {
      background: white;
      padding: 40px;
      border-radius: 16px;
      text-align: center;
      max-width: 400px;
    }
    .modal-content h2 {
      font-size: 32px;
      margin-bottom: 16px;
    }
    .modal-content.victory h2 {
      color: #4caf50;
    }
    .modal-content.defeat h2 {
      color: #f44336;
    }
    .modal-content p {
      font-size: 16px;
      color: #666;
      margin-bottom: 24px;
    }
    .modal-btn {
      padding: 12px 32px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      margin: 0 8px;
    }
    .modal-btn:hover {
      background: #5568d3;
      transform: translateY(-2px);
    }
    .tower-count {
      background: #fff3e0;
      border-left: 4px solid #ff9800;
      padding: 12px;
      border-radius: 4px;
      font-size: 13px;
      margin-bottom: 20px;
      color: #e65100;
      font-weight: bold;
    }
    .unit-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px solid #e0e0e0;
    }
    .money-display {
      background: #fff9c4;
      border-left: 4px solid #fbc02d;
      padding: 12px;
      border-radius: 4px;
      font-size: 14px;
      margin-bottom: 20px;
      color: #f57f17;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .level-display {
      background: #e1f5fe;
      border-left: 4px solid #0288d1;
      padding: 12px;
      border-radius: 4px;
      font-size: 16px;
      margin-bottom: 20px;
      color: #01579b;
      font-weight: bold;
      text-align: center;
    }
    .wave-preview {
      background: #fff3e0;
      border-left: 4px solid #f57c00;
      padding: 12px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    .wave-preview-title {
      font-size: 14px;
      font-weight: bold;
      color: #e65100;
      margin-bottom: 8px;
    }
    .wave-preview-content {
      font-size: 12px;
      color: #666;
      line-height: 1.6;
    }
    .enemy-type {
      display: inline-block;
      margin-right: 8px;
      padding: 2px 6px;
      background: rgba(0,0,0,0.05);
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="game-header">
      <h1>ğŸ—¼ æˆ¦ç•¥TD</h1>
      <div class="stats">
        <div class="stat">
          <span class="stat-icon">ğŸ°</span>
          <span id="player-hp">200</span>
        </div>
        <div class="stat">
          <span class="stat-icon">ğŸ’°</span>
          <span id="money-header">200</span>
        </div>
        <div class="stat">
          <span class="stat-icon">ğŸ‘¹</span>
          <span id="enemy-hp">150</span>
        </div>
      </div>
    </div>

    <div id="game-content">
      <div id="canvas-container">
        <canvas id="canvas" width="1200" height="720"></canvas>
      </div>

      <div id="sidebar">
        <div class="level-display">
          ğŸ“Š Level <span id="level">1 / 3</span>
        </div>

        <div class="phase-indicator" id="phase-indicator">
          é…ç½®ãƒ•ã‚§ãƒ¼ã‚º
        </div>

        <div class="wave-preview" id="wave-preview" style="display: none;">
          <div class="wave-preview-title">ğŸ“¡ æ¬¡ã®Waveäºˆå‘Š</div>
          <div class="wave-preview-content" id="wave-preview-content">
            æ•µæƒ…å ±ã‚’åˆ†æä¸­...
          </div>
        </div>

        <div class="money-display">
          ğŸ’° æ‰€æŒé‡‘: <span id="money">200</span>
        </div>

        <div class="tower-count">
          æ®‹ã‚ŠMP: <span id="remaining-mp">100</span> / 100
        </div>

        <div class="tower-section">
          <h3>ã‚¿ãƒ¯ãƒ¼é…ç½®</h3>

          <button class="tower-btn" data-tower="cannon">
            <div class="tower-btn-title">
              <span>ğŸ’¥ å¤§ç ²</span>
              <span style="color: #9c27b0;">25MP</span>
            </div>
            <div class="tower-btn-desc">
              ç¯„å›²æ”»æ’ƒ / ç¾¤ã‚Œã«æœ‰åŠ¹<br>
              æ”»æ’ƒ: 30
            </div>
          </button>

          <button class="tower-btn" data-tower="sniper">
            <div class="tower-btn-title">
              <span>ğŸ¯ ç‹™æ’ƒ</span>
              <span style="color: #9c27b0;">40MP</span>
            </div>
            <div class="tower-btn-desc">
              å˜ä½“é«˜ç«åŠ› / ç¡¬ã„æ•µã«æœ‰åŠ¹<br>
              æ”»æ’ƒ: 100
            </div>
          </button>

          <button class="tower-btn" data-tower="slow">
            <div class="tower-btn-title">
              <span>â„ï¸ æ¸›é€Ÿ</span>
              <span style="color: #9c27b0;">15MP</span>
            </div>
            <div class="tower-btn-desc">
              æ•µã‚’50%æ¸›é€Ÿ / é€Ÿã„æ•µã«æœ‰åŠ¹
            </div>
          </button>
        </div>

        <div class="unit-section" id="unit-section" style="display: none;">
          <h3>å…µå£«å‡ºæ’ƒ</h3>

          <button class="unit-btn" id="soldier-btn">
            <div class="unit-btn-title">
              <span>âš”ï¸ å‰£å£«</span>
              <span>30</span>
            </div>
            <div class="unit-btn-desc">
              HP: 50 / æ”»æ’ƒ: 15
            </div>
          </button>

          <button class="unit-btn" id="archer-btn">
            <div class="unit-btn-title">
              <span>ğŸ¹ å¼“å…µ</span>
              <span>50</span>
            </div>
            <div class="unit-btn-desc">
              HP: 30 / æ”»æ’ƒ: 30
            </div>
          </button>
        </div>

        <button class="start-btn" id="start-btn">
          âš”ï¸ æˆ¦é—˜é–‹å§‹
        </button>

        <div class="info-box">
          <strong>ç›®æ¨™ï¼š</strong>æ•µã®åŸã‚’ç ´å£Š<br><br>
          <strong>Tipsï¼š</strong><br>
          ãƒ»ã‚¿ãƒ¯ãƒ¼ã‚’ã‚¯ãƒªãƒƒã‚¯ã§å¼·åŒ–å¯èƒ½<br>
          ãƒ»æ•µã‚¿ã‚¤ãƒ—ã§æœ‰åŠ¹ãªé˜²å¾¡ãŒé•ã†<br>
          ãƒ»æ¬¡Waveäºˆå‘Šã‚’è¦‹ã¦æº–å‚™ã—ã‚ˆã†
        </div>
      </div>
    </div>
  </div>

  <div id="modal">
    <div class="modal-content" id="modal-content">
      <h2 id="modal-title">Victory!</h2>
      <p id="modal-message">æ•µã®åŸã‚’ç ´å£Šã—ã¾ã—ãŸï¼</p>
      <button class="modal-btn" id="next-level-btn">æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¸</button>
      <button class="modal-btn" onclick="location.reload()">æœ€åˆã‹ã‚‰</button>
    </div>
  </div>

  <div id="rush-notification">
    ğŸš¨ RUSH TIME! ğŸš¨
  </div>

  <script>
    // ========================================
    // å®šæ•°
    // ========================================
    const CANVAS_WIDTH = 1200;
    const CANVAS_HEIGHT = 720;
    const GRID_SIZE = 10;
    const CELL_SIZE = CANVAS_WIDTH / GRID_SIZE;
    const MAX_MP = 100;
    const START_MONEY = 250;

    // æ•µã‚¿ã‚¤ãƒ—å®šç¾©ï¼ˆ4ç¨®é¡ï¼‰
    const ENEMY_TYPES = {
      fast: {
        name: 'é€Ÿæ”»å‹',
        icon: 'ğŸƒ',
        color: '#ffeb3b',
        hp: 40,
        speed: 2.5,
        damage: 20,
        castleAttack: 6,
        reward: 30
      },
      tank: {
        name: 'é‡è£…ç”²',
        icon: 'ğŸ›¡ï¸',
        color: '#607d8b',
        hp: 200,
        speed: 0.8,
        damage: 40,
        castleAttack: 16,
        reward: 60
      },
      swarm: {
        name: 'ç¾¤ã‚Œ',
        icon: 'ğŸ‘¥',
        color: '#9c27b0',
        hp: 25,
        speed: 1.2,
        damage: 16,
        castleAttack: 4,
        reward: 16
      },
      ranged: {
        name: 'é è·é›¢',
        icon: 'ğŸ¹',
        color: '#f44336',
        hp: 50,
        speed: 1.0,
        damage: 50,
        castleAttack: 10,
        reward: 40,
        range: 100
      }
    };

    // ã‚¿ãƒ¯ãƒ¼å®šç¾©ï¼ˆã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰å¯¾å¿œï¼‰
    const TOWER_TYPES = {
      cannon: {
        name: 'å¤§ç ²',
        icon: 'ğŸ’¥',
        color: '#ff6b6b',
        mpCost: 25,
        levels: [
          { damage: 20, range: 1.5, attackSpeed: 800, cost: 0, hp: 120, maxHp: 120 },
          { damage: 35, range: 1.8, attackSpeed: 700, cost: 80, hp: 170, maxHp: 170 },
          { damage: 55, range: 2.0, attackSpeed: 600, cost: 150, hp: 230, maxHp: 230 }
        ],
        effect: 'damage'
      },
      sniper: {
        name: 'ç‹™æ’ƒ',
        icon: 'ğŸ¯',
        color: '#4ecdc4',
        mpCost: 40,
        levels: [
          { damage: 65, range: 2, attackSpeed: 1500, cost: 0, hp: 100, maxHp: 100 },
          { damage: 120, range: 2.5, attackSpeed: 1300, cost: 100, hp: 150, maxHp: 150 },
          { damage: 200, range: 3, attackSpeed: 1100, cost: 200, hp: 200, maxHp: 200 }
        ],
        effect: 'damage'
      },
      slow: {
        name: 'æ¸›é€Ÿ',
        icon: 'â„ï¸',
        color: '#95e1d3',
        mpCost: 15,
        levels: [
          { damage: 0, range: 1.5, attackSpeed: 0, cost: 0, slowAmount: 0.5, hp: 80, maxHp: 80 },
          { damage: 0, range: 2.0, attackSpeed: 0, cost: 60, slowAmount: 0.3, hp: 120, maxHp: 120 },
          { damage: 0, range: 2.5, attackSpeed: 0, cost: 120, slowAmount: 0.2, hp: 160, maxHp: 160 }
        ],
        effect: 'slow'
      }
    };

    // ãƒ¦ãƒ‹ãƒƒãƒˆå®šç¾©
    const UNIT_TYPES = {
      soldier: {
        name: 'å‰£å£«',
        icon: 'âš”ï¸',
        color: '#4caf50',
        hp: 80,
        damage: 15,
        speed: 1.5,
        range: 25,
        attackSpeed: 1000,
        cost: 30,
        castleAttack: 5
      },
      archer: {
        name: 'å¼“å…µ',
        icon: 'ğŸ¹',
        color: '#2196f3',
        hp: 50,
        damage: 30,
        speed: 1.2,
        range: 80,
        attackSpeed: 1500,
        cost: 50,
        castleAttack: 10
      }
    };

    // ========================================
    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    // ========================================
    const game = {
      phase: 'placement',
      level: 1,
      money: START_MONEY,
      mp: MAX_MP,
      playerCastleHp: 200,
      enemyCastleHp: 150,
      towers: [],
      enemyTowers: [],
      playerUnits: [],
      enemyUnits: [],
      selectedTower: null,
      gameOver: false,
      enemySpawnTimer: 0,
      nextWaveComposition: null,
      selectedTowerForUpgrade: null,
      rushMode: false,
      rushTimer: 0,
      rushCheckTimer: 0,
      rushDuration: 0
    };

    // ========================================
    // Canvas
    // ========================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // ========================================
    // Waveæ§‹æˆç”Ÿæˆ
    // ========================================
    function generateWaveComposition(level) {
      const compositions = [
        // Level 1: é«˜é›£æ˜“åº¦
        { fast: 15, tank: 6, swarm: 20, ranged: 8 },
        // Level 2: è¶…é«˜é›£æ˜“åº¦
        { fast: 20, tank: 8, swarm: 28, ranged: 12 },
        // Level 3: æœ€é«˜é›£æ˜“åº¦
        { fast: 25, tank: 10, swarm: 35, ranged: 15 }
      ];

      const index = Math.min(level - 1, compositions.length - 1);
      return compositions[index];
    }

    // ========================================
    // Waveäºˆå‘Šè¡¨ç¤ºæ›´æ–°
    // ========================================
    function updateWavePreview() {
      if (game.phase !== 'battle') return;

      const preview = document.getElementById('wave-preview');
      const content = document.getElementById('wave-preview-content');

      if (!game.nextWaveComposition) {
        preview.style.display = 'none';
        return;
      }

      preview.style.display = 'block';

      let html = '';
      for (const [type, count] of Object.entries(game.nextWaveComposition)) {
        if (count > 0) {
          const enemy = ENEMY_TYPES[type];
          html += `<span class="enemy-type">${enemy.icon} ${enemy.name} x${count}</span>`;
        }
      }

      content.innerHTML = html;
    }

    // ========================================
    // ã‚°ãƒªãƒƒãƒ‰æç”»
    // ========================================
    function drawGrid() {
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;

      for (let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, CANVAS_HEIGHT);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(CANVAS_WIDTH, i * CELL_SIZE);
        ctx.stroke();
      }

      ctx.fillStyle = 'rgba(76, 175, 80, 0.1)';
      ctx.fillRect(0, 0, CELL_SIZE * 4, CANVAS_HEIGHT);

      ctx.fillStyle = 'rgba(244, 67, 54, 0.1)';
      ctx.fillRect(CELL_SIZE * 6, 0, CELL_SIZE * 4, CANVAS_HEIGHT);

      // ã‚°ãƒªãƒƒãƒ‰ç•ªå·ã‚’è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
      ctx.fillStyle = '#666';
      ctx.font = '12px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          ctx.fillText(`${x},${y}`, x * CELL_SIZE + 5, y * CELL_SIZE + 5);
        }
      }

      // å‘³æ–¹ã®åŸ
      const playerCastleX = CELL_SIZE * 1;
      const playerCastleY = CANVAS_HEIGHT / 2;
      const castleSize = 80;
      ctx.fillStyle = '#4caf50';
      ctx.fillRect(playerCastleX - castleSize / 2, playerCastleY - castleSize / 2, castleSize, castleSize);
      ctx.fillStyle = 'white';
      ctx.font = 'bold 40px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('ğŸ°', playerCastleX, playerCastleY);

      // HPã‚²ãƒ¼ã‚¸ï¼ˆåŸã®ç®±ã¨åŒã˜å¹…ï¼‰
      ctx.fillStyle = '#333';
      ctx.fillRect(playerCastleX - 40, playerCastleY + 50, 80, 8);
      const playerHpPercent = game.playerCastleHp / getPlayerMaxHp();
      ctx.fillStyle = '#4caf50';
      ctx.fillRect(playerCastleX - 40, playerCastleY + 50, 80 * playerHpPercent, 8);

      // æ•µã®åŸ
      const enemyCastleX = CANVAS_WIDTH - CELL_SIZE * 1;
      const enemyCastleY = CANVAS_HEIGHT / 2;
      ctx.fillStyle = '#f44336';
      ctx.fillRect(enemyCastleX - castleSize / 2, enemyCastleY - castleSize / 2, castleSize, castleSize);
      ctx.fillStyle = 'white';
      ctx.fillText('ğŸ‘¹', enemyCastleX, enemyCastleY);

      // HPã‚²ãƒ¼ã‚¸ï¼ˆåŸã®ç®±ã¨åŒã˜å¹…ï¼‰
      ctx.fillStyle = '#333';
      ctx.fillRect(enemyCastleX - 40, enemyCastleY + 50, 80, 8);
      const enemyHpPercent = game.enemyCastleHp / getEnemyMaxHp();
      ctx.fillStyle = '#f44336';
      ctx.fillRect(enemyCastleX - 40, enemyCastleY + 50, 80 * enemyHpPercent, 8);
    }

    // ========================================
    // æ•µã‚¿ãƒ¯ãƒ¼è‡ªå‹•é…ç½®
    // ========================================
    function placeEnemyTowers() {
      game.enemyTowers = [];

      // ãƒ¬ãƒ™ãƒ«åˆ¥ã®ã‚¿ãƒ¯ãƒ¼æ•°: Level 1: 1å€‹, Level 2: 1å€‹, Level 3: 2å€‹
      const towerCounts = [1, 1, 2];
      const towerCount = towerCounts[Math.min(game.level - 1, towerCounts.length - 1)];

      // æ•µã‚¿ãƒ¯ãƒ¼é…ç½®ç¯„å›²: gridX 6-7, gridY 0-5 ã®12ãƒã‚¹
      const enemyGridXRange = [6, 7];
      const gridYRange = [0, 1, 2, 3, 4, 5];

      // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«é…ç½®ï¼ˆé‡è¤‡ãªã—ï¼‰
      const placedPositions = new Set();
      let placedCount = 0;

      while (placedCount < towerCount) {
        const gridX = enemyGridXRange[Math.floor(Math.random() * enemyGridXRange.length)];
        const gridY = gridYRange[Math.floor(Math.random() * gridYRange.length)];
        const posKey = `${gridX},${gridY}`;

        if (!placedPositions.has(posKey)) {
          placedPositions.add(posKey);

          // ã‚¿ãƒ¯ãƒ¼ã‚¿ã‚¤ãƒ—ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠï¼ˆcannon, sniper, slowï¼‰
          const towerTypes = ['cannon', 'sniper', 'slow'];
          const towerType = towerTypes[Math.floor(Math.random() * towerTypes.length)];
          const towerDef = TOWER_TYPES[towerType];
          const levelStats = towerDef.levels[0]; // æ•µã‚¿ãƒ¯ãƒ¼ã¯ãƒ¬ãƒ™ãƒ«1

          game.enemyTowers.push({
            gridX: gridX,
            gridY: gridY,
            type: towerType,
            level: 0,
            lastAttackTime: 0,
            lastAttack: 0,
            hp: levelStats.hp,
            maxHp: levelStats.maxHp
          });

          placedCount++;
        }
      }
    }

    // ========================================
    // ã‚¿ãƒ¯ãƒ¼æç”»
    // ========================================
    function drawTowers() {
      game.towers.forEach(tower => {
        const typeDef = TOWER_TYPES[tower.type];
        const level = typeDef.levels[tower.level];
        const x = tower.gridX * CELL_SIZE + CELL_SIZE / 2;
        const y = tower.gridY * CELL_SIZE + CELL_SIZE / 2;

        // ç¯„å›²è¡¨ç¤º
        ctx.fillStyle = typeDef.color + '20';
        ctx.beginPath();
        ctx.arc(x, y, level.range * CELL_SIZE, 0, Math.PI * 2);
        ctx.fill();

        // é¸æŠè¡¨ç¤º
        if (game.selectedTowerForUpgrade === tower) {
          ctx.strokeStyle = '#ffeb3b';
          ctx.lineWidth = 3;
          ctx.strokeRect(
            tower.gridX * CELL_SIZE + 5,
            tower.gridY * CELL_SIZE + 5,
            CELL_SIZE - 10,
            CELL_SIZE - 10
          );
        }

        // ã‚¿ãƒ¯ãƒ¼æœ¬ä½“ï¼ˆHPãŒ0ãªã‚‰åŠé€æ˜ï¼‰
        ctx.fillStyle = tower.hp > 0 ? typeDef.color : typeDef.color + '60';
        ctx.fillRect(x - 30, y - 30, 60, 60);

        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(typeDef.icon, x, y);

        // ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
        ctx.fillStyle = 'white';
        ctx.font = 'bold 14px Arial';
        ctx.fillText(`Lv${tower.level + 1}`, x, y - 45);

        // HPè¡¨ç¤º
        const hpBarWidth = 60;
        ctx.fillStyle = '#333';
        ctx.fillRect(x - hpBarWidth / 2, y + 35, hpBarWidth, 4);
        const hpPercent = tower.hp / tower.maxHp;
        ctx.fillStyle = hpPercent > 0.5 ? '#4caf50' : hpPercent > 0.25 ? '#ff9800' : '#f44336';
        ctx.fillRect(x - hpBarWidth / 2, y + 35, hpBarWidth * hpPercent, 4);

        // æ”»æ’ƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        if (tower.lastAttack && Date.now() - tower.lastAttack < 200) {
          ctx.strokeStyle = typeDef.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(x, y, level.range * CELL_SIZE * 0.8, 0, Math.PI * 2);
          ctx.stroke();
        }
      });
    }

    // ========================================
    // æ•µã‚¿ãƒ¯ãƒ¼æç”»
    // ========================================
    function drawEnemyTowers() {
      game.enemyTowers.forEach(tower => {
        const typeDef = TOWER_TYPES[tower.type];
        const level = typeDef.levels[tower.level];
        const x = tower.gridX * CELL_SIZE + CELL_SIZE / 2;
        const y = tower.gridY * CELL_SIZE + CELL_SIZE / 2;

        // ç¯„å›²è¡¨ç¤º
        ctx.fillStyle = typeDef.color + '20';
        ctx.beginPath();
        ctx.arc(x, y, level.range * CELL_SIZE, 0, Math.PI * 2);
        ctx.fill();

        // ã‚¿ãƒ¯ãƒ¼æœ¬ä½“ï¼ˆHPãŒ0ãªã‚‰åŠé€æ˜ï¼‰
        ctx.fillStyle = tower.hp > 0 ? typeDef.color : typeDef.color + '60';
        ctx.fillRect(x - 30, y - 30, 60, 60);

        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(typeDef.icon, x, y);

        // ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
        ctx.fillStyle = 'white';
        ctx.font = 'bold 14px Arial';
        ctx.fillText(`Lv${tower.level + 1}`, x, y - 45);

        // HPè¡¨ç¤º
        const hpBarWidth = 60;
        ctx.fillStyle = '#333';
        ctx.fillRect(x - hpBarWidth / 2, y + 35, hpBarWidth, 4);
        const hpPercent = tower.hp / tower.maxHp;
        ctx.fillStyle = hpPercent > 0.5 ? '#4caf50' : hpPercent > 0.25 ? '#ff9800' : '#f44336';
        ctx.fillRect(x - hpBarWidth / 2, y + 35, hpBarWidth * hpPercent, 4);

        // æ”»æ’ƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        if (tower.lastAttack && Date.now() - tower.lastAttack < 200) {
          ctx.strokeStyle = typeDef.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(x, y, level.range * CELL_SIZE * 0.8, 0, Math.PI * 2);
          ctx.stroke();
        }
      });
    }

    // ========================================
    // ãƒ¦ãƒ‹ãƒƒãƒˆæç”»
    // ========================================
    function drawUnits() {
      [...game.playerUnits, ...game.enemyUnits].forEach(unit => {
        const isPlayer = unit.isPlayer;

        if (unit.inCombat) {
          ctx.strokeStyle = '#ff9800';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(unit.x, unit.y, 20, 0, Math.PI * 2);
          ctx.stroke();
        }

        let color, icon;
        if (isPlayer) {
          const type = UNIT_TYPES[unit.type];
          color = type.color;
          icon = type.icon;
        } else {
          const type = ENEMY_TYPES[unit.enemyType];
          color = type.color;
          icon = type.icon;
        }

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(unit.x, unit.y, 15, 0, Math.PI * 2);
        ctx.fill();

        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(icon, unit.x, unit.y);

        const hpY = isPlayer ? unit.y + 22 : unit.y - 28;
        const unitHpBarWidth = 30; // ãƒ¦ãƒ‹ãƒƒãƒˆã®å††ã®ç›´å¾„ã¨åŒã˜
        ctx.fillStyle = '#333';
        ctx.fillRect(unit.x - unitHpBarWidth / 2, hpY, unitHpBarWidth, 4);

        const hpPercent = unit.hp / unit.maxHp;
        ctx.fillStyle = hpPercent > 0.5 ? '#4caf50' : hpPercent > 0.25 ? '#ff9800' : '#f44336';
        ctx.fillRect(unit.x - unitHpBarWidth / 2, hpY, unitHpBarWidth * hpPercent, 4);
      });
    }

    // ========================================
    // ãƒã‚¦ã‚¹ãƒ›ãƒãƒ¼
    // ========================================
    let mousePos = { x: 0, y: 0 };

    function drawPlacementPreview() {
      if (game.phase !== 'placement' || !game.selectedTower) return;

      const gridX = Math.floor(mousePos.x / CELL_SIZE);
      const gridY = Math.floor(mousePos.y / CELL_SIZE);

      if (gridX >= 4 || gridX < 1) return;

      const typeDef = TOWER_TYPES[game.selectedTower];
      const level = typeDef.levels[0];
      const x = gridX * CELL_SIZE + CELL_SIZE / 2;
      const y = gridY * CELL_SIZE + CELL_SIZE / 2;

      ctx.fillStyle = typeDef.color + '40';
      ctx.fillRect(gridX * CELL_SIZE, gridY * CELL_SIZE, CELL_SIZE, CELL_SIZE);

      ctx.fillStyle = typeDef.color + '80';
      ctx.fillRect(x - 30, y - 30, 60, 60);

      ctx.font = '30px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(typeDef.icon, x, y);
    }

    // ========================================
    // æç”»ãƒ¡ã‚¤ãƒ³
    // ========================================
    function draw() {
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      drawGrid();
      drawTowers();
      drawEnemyTowers();
      drawUnits();
      drawPlacementPreview();
    }

    // ========================================
    // ãƒ¦ãƒ‹ãƒƒãƒˆç§»å‹•
    // ========================================
    function moveUnits(deltaTime) {
      [...game.playerUnits, ...game.enemyUnits].forEach(unit => {
        if (unit.inCombat) return;
        if (unit.attackingCastle) return;

        const speed = unit.speed * deltaTime;

        if (unit.isPlayer) {
          unit.x += speed;
        } else {
          unit.x -= speed;
        }
      });
    }

    // ========================================
    // ãƒ¦ãƒ‹ãƒƒãƒˆæˆ¦é—˜
    // ========================================
    function unitCombat() {
      const now = Date.now();

      [...game.playerUnits, ...game.enemyUnits].forEach(unit => {
        if (unit.attackingCastle) return;

        const enemies = unit.isPlayer ? game.enemyUnits : game.playerUnits;

        const nearbyEnemies = enemies.filter(enemy => {
          const dx = enemy.x - unit.x;
          const dy = enemy.y - unit.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          return dist <= unit.range;
        });

        if (nearbyEnemies.length > 0) {
          unit.inCombat = true;
          const target = nearbyEnemies[0];
          target.inCombat = true;

          if (!unit.lastAttackTime || now - unit.lastAttackTime > unit.attackSpeed) {
            target.hp -= unit.damage;
            unit.lastAttackTime = now;
          }
        } else {
          unit.inCombat = false;
        }
      });

      game.playerUnits = game.playerUnits.filter(u => {
        if (u.hp <= 0) {
          game.money += 10;
          updateUI();
          return false;
        }
        return true;
      });

      game.enemyUnits = game.enemyUnits.filter(u => {
        if (u.hp <= 0) {
          const enemyType = ENEMY_TYPES[u.enemyType];
          game.money += enemyType.reward;
          updateUI();
          return false;
        }
        return true;
      });
    }

    // ========================================
    // åŸæ”»æ’ƒ
    // ========================================
    function castleAttack() {
      const now = Date.now();

      game.playerUnits.forEach(unit => {
        const enemyCastleX = CANVAS_WIDTH - CELL_SIZE * 1;
        const dist = Math.abs(unit.x - enemyCastleX);

        if (dist < 100 && !unit.inCombat) {
          unit.attackingCastle = true;

          if (!unit.lastCastleAttack || now - unit.lastCastleAttack > 1000) {
            game.enemyCastleHp -= unit.castleAttack;
            unit.lastCastleAttack = now;
            updateUI();
            checkGameOver();
          }
        }
      });

      game.enemyUnits.forEach(unit => {
        const playerCastleX = CELL_SIZE * 1;
        const dist = Math.abs(unit.x - playerCastleX);

        if (dist < 100 && !unit.inCombat) {
          unit.attackingCastle = true;

          if (!unit.lastCastleAttack || now - unit.lastCastleAttack > 1000) {
            game.playerCastleHp -= unit.castleAttack;
            unit.lastCastleAttack = now;
            updateUI();
            checkGameOver();
          }
        }
      });
    }

    // ========================================
    // ã‚¿ãƒ¯ãƒ¼æ”»æ’ƒ
    // ========================================
    function towerAttack() {
      const now = Date.now();

      game.towers.forEach(tower => {
        if (tower.hp <= 0) return; // HPãŒ0ãªã‚‰æ”»æ’ƒã—ãªã„

        const typeDef = TOWER_TYPES[tower.type];
        const level = typeDef.levels[tower.level];

        if (typeDef.effect !== 'damage') return;
        if (tower.lastAttackTime && now - tower.lastAttackTime < level.attackSpeed) return;

        const x = tower.gridX * CELL_SIZE + CELL_SIZE / 2;
        const y = tower.gridY * CELL_SIZE + CELL_SIZE / 2;

        const enemiesInRange = game.enemyUnits.filter(enemy => {
          const dx = enemy.x - x;
          const dy = enemy.y - y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          return dist <= level.range * CELL_SIZE;
        });

        if (enemiesInRange.length === 0) return;

        tower.lastAttackTime = now;
        tower.lastAttack = now;

        if (tower.type === 'cannon') {
          enemiesInRange.forEach(enemy => {
            enemy.hp -= level.damage;
          });
        } else if (tower.type === 'sniper') {
          enemiesInRange[0].hp -= level.damage;
        }
      });
    }

    // ========================================
    // æ•µãŒã‚¿ãƒ¯ãƒ¼ã‚’æ”»æ’ƒ
    // ========================================
    function enemyAttackTowers() {
      const now = Date.now();

      game.enemyUnits.forEach(enemy => {
        if (enemy.inCombat || enemy.attackingCastle) return;

        game.towers.forEach(tower => {
          if (tower.hp <= 0) return;

          const towerX = tower.gridX * CELL_SIZE + CELL_SIZE / 2;
          const towerY = tower.gridY * CELL_SIZE + CELL_SIZE / 2;

          const dx = towerX - enemy.x;
          const dy = towerY - enemy.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist <= 50) {
            if (!enemy.lastTowerAttack || now - enemy.lastTowerAttack > 1000) {
              tower.hp -= 5;
              enemy.lastTowerAttack = now;
            }
          }
        });
      });
    }

    // ========================================
    // æ•µã‚¿ãƒ¯ãƒ¼æ”»æ’ƒï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¦ãƒ‹ãƒƒãƒˆã‚’æ”»æ’ƒï¼‰
    // ========================================
    function enemyTowerAttack() {
      const now = Date.now();

      game.enemyTowers.forEach(tower => {
        if (tower.hp <= 0) return; // HPãŒ0ãªã‚‰æ”»æ’ƒã—ãªã„

        const typeDef = TOWER_TYPES[tower.type];
        const level = typeDef.levels[tower.level];

        if (typeDef.effect !== 'damage') return;
        if (tower.lastAttackTime && now - tower.lastAttackTime < level.attackSpeed) return;

        const x = tower.gridX * CELL_SIZE + CELL_SIZE / 2;
        const y = tower.gridY * CELL_SIZE + CELL_SIZE / 2;

        const playersInRange = game.playerUnits.filter(player => {
          const dx = player.x - x;
          const dy = player.y - y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          return dist <= level.range * CELL_SIZE;
        });

        if (playersInRange.length === 0) return;

        tower.lastAttackTime = now;
        tower.lastAttack = now;

        if (tower.type === 'cannon') {
          playersInRange.forEach(player => {
            player.hp -= level.damage;
          });
        } else if (tower.type === 'sniper') {
          playersInRange[0].hp -= level.damage;
        }
      });
    }

    // ========================================
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¦ãƒ‹ãƒƒãƒˆãŒæ•µã‚¿ãƒ¯ãƒ¼ã‚’æ”»æ’ƒ
    // ========================================
    function playerAttackEnemyTowers() {
      const now = Date.now();

      game.playerUnits.forEach(player => {
        if (player.inCombat || player.attackingCastle) return;

        game.enemyTowers.forEach(tower => {
          if (tower.hp <= 0) return;

          const towerX = tower.gridX * CELL_SIZE + CELL_SIZE / 2;
          const towerY = tower.gridY * CELL_SIZE + CELL_SIZE / 2;

          const dx = towerX - player.x;
          const dy = towerY - player.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist <= 50) {
            if (!player.lastTowerAttack || now - player.lastTowerAttack > 1000) {
              tower.hp -= 5;
              player.lastTowerAttack = now;
            }
          }
        });
      });
    }

    // ========================================
    // ãƒ©ãƒƒã‚·ãƒ¥ãƒ¢ãƒ¼ãƒ‰ç®¡ç†
    // ========================================
    function manageRushMode(deltaTime) {
      game.rushCheckTimer += deltaTime;

      // 10ç§’ã”ã¨ã«ãƒ©ãƒƒã‚·ãƒ¥ãƒ¢ãƒ¼ãƒ‰ã®åˆ¤å®š
      if (game.rushCheckTimer >= 10000 && !game.rushMode) {
        game.rushCheckTimer = 0;

        // ãƒ¬ãƒ™ãƒ«åˆ¥ã®ç™ºç”Ÿç¢ºç‡ã§ãƒ©ãƒƒã‚·ãƒ¥ãƒ¢ãƒ¼ãƒ‰ç™ºå‹•
        const rushProbabilities = [0.4, 0.45, 0.5]; // Level 1: 40%, Level 2: 45%, Level 3: 50%
        const probability = rushProbabilities[Math.min(game.level - 1, rushProbabilities.length - 1)];

        if (Math.random() < probability) {
          game.rushMode = true;
          game.rushDuration = 0;
          document.getElementById('rush-notification').classList.add('show');
        }
      }

      // ãƒ©ãƒƒã‚·ãƒ¥ãƒ¢ãƒ¼ãƒ‰ä¸­ã®ã‚¿ã‚¤ãƒãƒ¼
      if (game.rushMode) {
        game.rushDuration += deltaTime;

        // 3ç§’çµŒéã—ãŸã‚‰ãƒ©ãƒƒã‚·ãƒ¥ãƒ¢ãƒ¼ãƒ‰çµ‚äº†
        if (game.rushDuration >= 3000) {
          game.rushMode = false;
          game.rushDuration = 0;
          document.getElementById('rush-notification').classList.remove('show');
        }
      }
    }

    // ========================================
    // æ•µå‡ºæ’ƒ
    // ========================================
    function enemySpawn(deltaTime) {
      game.enemySpawnTimer += deltaTime;

      // ãƒ©ãƒƒã‚·ãƒ¥ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯ã‚¹ãƒãƒ¼ãƒ³é–“éš”ã‚’å¤§å¹…ã«çŸ­ç¸®
      let spawnInterval = Math.max(800, 1500 - game.level * 80);
      if (game.rushMode) {
        spawnInterval = spawnInterval / 5; // 5å€é€Ÿ
      }

      if (game.enemySpawnTimer >= spawnInterval) {
        game.enemySpawnTimer = 0;

        if (!game.nextWaveComposition) {
          game.nextWaveComposition = generateWaveComposition(game.level);
          updateWavePreview();
        }

        // æ¬¡ã«å‡ºæ’ƒã™ã‚‹æ•µã‚¿ã‚¤ãƒ—ã‚’æ±ºå®š
        let selectedType = null;
        for (const [type, count] of Object.entries(game.nextWaveComposition)) {
          if (count > 0) {
            selectedType = type;
            game.nextWaveComposition[type]--;
            break;
          }
        }

        if (!selectedType) {
          // å…¨ã¦å‡ºæ’ƒæ¸ˆã¿ã€æ¬¡Waveæº–å‚™
          game.nextWaveComposition = generateWaveComposition(game.level);
          updateWavePreview();
          return;
        }

        const enemyDef = ENEMY_TYPES[selectedType];
        const hpMultiplier = 1 + game.level * 0.1;
        const damageMultiplier = 1 + game.level * 0.08;

        game.enemyUnits.push({
          x: CANVAS_WIDTH - CELL_SIZE * 1,
          y: CANVAS_HEIGHT / 2 + (Math.random() - 0.5) * 200,
          hp: enemyDef.hp * hpMultiplier,
          maxHp: enemyDef.hp * hpMultiplier,
          speed: enemyDef.speed,
          damage: enemyDef.damage * damageMultiplier,
          range: enemyDef.range || 25,
          attackSpeed: 1000,
          castleAttack: enemyDef.castleAttack,
          enemyType: selectedType,
          isPlayer: false,
          inCombat: false,
          attackingCastle: false,
          lastAttackTime: 0,
          lastCastleAttack: 0
        });
      }
    }

    // ========================================
    // å…µå£«å‡ºæ’ƒ
    // ========================================
    function spawnUnit(unitType) {
      const type = UNIT_TYPES[unitType];

      if (game.money < type.cost) return;

      game.money -= type.cost;

      game.playerUnits.push({
        x: CELL_SIZE * 1,
        y: CANVAS_HEIGHT / 2 + (Math.random() - 0.5) * 200,
        hp: type.hp,
        maxHp: type.hp,
        speed: type.speed,
        damage: type.damage,
        range: type.range,
        attackSpeed: type.attackSpeed,
        castleAttack: type.castleAttack,
        type: unitType,
        isPlayer: true,
        inCombat: false,
        attackingCastle: false,
        lastAttackTime: 0,
        lastCastleAttack: 0
      });

      updateUI();
    }

    // ========================================
    // ã‚¿ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰
    // ========================================
    function upgradeTower(tower) {
      const typeDef = TOWER_TYPES[tower.type];

      if (tower.level >= typeDef.levels.length - 1) {
        return; // æœ€å¤§ãƒ¬ãƒ™ãƒ«
      }

      const nextLevel = typeDef.levels[tower.level + 1];

      if (game.money < nextLevel.cost) {
        return; // ãŠé‡‘ä¸è¶³
      }

      game.money -= nextLevel.cost;
      tower.level++;
      tower.hp = nextLevel.hp;
      tower.maxHp = nextLevel.maxHp;
      game.selectedTowerForUpgrade = null;

      updateUI();
    }

    // ========================================
    // ãƒ¬ãƒ™ãƒ«è¨ˆç®—
    // ========================================
    function getPlayerMaxHp() {
      return 200 + game.level * 50;
    }

    function getEnemyMaxHp() {
      return 150 + game.level * 40;
    }

    // ========================================
    // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
    // ========================================
    let lastTime = Date.now();

    function gameLoop() {
      const now = Date.now();
      const deltaTimeMs = now - lastTime;
      const deltaTime = deltaTimeMs / 16.67;
      lastTime = now;

      if (game.phase === 'battle' && !game.gameOver) {
        moveUnits(deltaTime);
        unitCombat();
        castleAttack();
        towerAttack();
        enemyTowerAttack();
        enemyAttackTowers();
        playerAttackEnemyTowers();
        enemySpawn(deltaTimeMs);
        manageRushMode(deltaTimeMs);
      }

      draw();
      requestAnimationFrame(gameLoop);
    }

    // ========================================
    // UIæ›´æ–°
    // ========================================
    function updateUI() {
      document.getElementById('level').textContent = `${game.level} / 3`;
      document.getElementById('player-hp').textContent = Math.max(0, Math.floor(game.playerCastleHp));
      document.getElementById('enemy-hp').textContent = Math.max(0, Math.floor(game.enemyCastleHp));
      document.getElementById('money').textContent = game.money;
      document.getElementById('money-header').textContent = game.money;
      document.getElementById('remaining-mp').textContent = game.mp;

      const phaseIndicator = document.getElementById('phase-indicator');
      if (game.phase === 'placement') {
        phaseIndicator.textContent = 'é…ç½®ãƒ•ã‚§ãƒ¼ã‚º';
        phaseIndicator.classList.remove('battle');
      } else {
        phaseIndicator.textContent = 'æˆ¦é—˜ãƒ•ã‚§ãƒ¼ã‚º';
        phaseIndicator.classList.add('battle');
      }

      document.querySelectorAll('.tower-btn').forEach(btn => {
        const towerType = btn.dataset.tower;
        const mpCost = TOWER_TYPES[towerType].mpCost;
        btn.disabled = game.phase !== 'placement' || game.mp < mpCost;
      });

      const startBtn = document.getElementById('start-btn');
      startBtn.disabled = game.phase !== 'placement';

      document.getElementById('soldier-btn').disabled = game.money < UNIT_TYPES.soldier.cost;
      document.getElementById('archer-btn').disabled = game.money < UNIT_TYPES.archer.cost;

      updateWavePreview();
    }

    // ========================================
    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
    // ========================================
    function checkGameOver() {
      if (game.enemyCastleHp <= 0) {
        game.gameOver = true;
        showVictory();
      } else if (game.playerCastleHp <= 0) {
        game.gameOver = true;
        showDefeat();
      }
    }

    function showVictory() {
      const modal = document.getElementById('modal');
      const content = document.getElementById('modal-content');
      content.classList.remove('defeat');
      content.classList.add('victory');
      document.getElementById('modal-title').textContent = 'ğŸ‰ Victory!';
      document.getElementById('modal-message').textContent = `Level ${game.level} ã‚¯ãƒªã‚¢ï¼`;
      document.getElementById('next-level-btn').style.display = 'inline-block';
      modal.classList.add('show');
    }

    function showDefeat() {
      const modal = document.getElementById('modal');
      const content = document.getElementById('modal-content');
      content.classList.remove('victory');
      content.classList.add('defeat');
      document.getElementById('modal-title').textContent = 'ğŸ’€ Defeat...';
      document.getElementById('modal-message').textContent = 'åŸãŒç ´å£Šã•ã‚Œã¾ã—ãŸ';
      document.getElementById('next-level-btn').style.display = 'none';
      modal.classList.add('show');
    }

    // ========================================
    // æ¬¡ã®ãƒ¬ãƒ™ãƒ«
    // ========================================
    function nextLevel() {
      game.level++;
      game.phase = 'placement';
      game.money = START_MONEY + game.level * 50;
      game.mp = MAX_MP;
      game.playerCastleHp = getPlayerMaxHp();
      game.enemyCastleHp = getEnemyMaxHp();
      game.towers = [];
      game.playerUnits = [];
      game.enemyUnits = [];
      game.selectedTower = null;
      game.gameOver = false;
      game.enemySpawnTimer = 0;
      game.nextWaveComposition = null;
      game.selectedTowerForUpgrade = null;

      placeEnemyTowers(); // æ•µã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®

      document.getElementById('modal').classList.remove('show');
      document.getElementById('wave-preview').style.display = 'none';
      updateUI();
    }

    // ========================================
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    // ========================================

    document.querySelectorAll('.tower-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const towerType = btn.dataset.tower;
        const mpCost = TOWER_TYPES[towerType].mpCost;

        if (game.phase !== 'placement' || game.mp < mpCost) return;

        document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        game.selectedTower = towerType;
      });
    });

    document.getElementById('start-btn').addEventListener('click', () => {
      game.phase = 'battle';
      game.nextWaveComposition = generateWaveComposition(game.level);
      document.getElementById('unit-section').style.display = 'block';
      updateUI();
    });

    document.getElementById('soldier-btn').addEventListener('click', () => {
      spawnUnit('soldier');
    });

    document.getElementById('archer-btn').addEventListener('click', () => {
      spawnUnit('archer');
    });

    document.getElementById('next-level-btn').addEventListener('click', () => {
      nextLevel();
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mousePos.x = e.clientX - rect.left;
      mousePos.y = e.clientY - rect.top;
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const gridX = Math.floor(x / CELL_SIZE);
      const gridY = Math.floor(y / CELL_SIZE);

      // æˆ¦é—˜ä¸­ï¼šã‚¿ãƒ¯ãƒ¼ã‚’ã‚¯ãƒªãƒƒã‚¯ã§ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰
      if (game.phase === 'battle') {
        const clickedTower = game.towers.find(t => t.gridX === gridX && t.gridY === gridY);

        if (clickedTower) {
          if (game.selectedTowerForUpgrade === clickedTower) {
            // 2å›ç›®ã‚¯ãƒªãƒƒã‚¯ï¼šã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰å®Ÿè¡Œ
            upgradeTower(clickedTower);
          } else {
            // 1å›ç›®ã‚¯ãƒªãƒƒã‚¯ï¼šé¸æŠ
            game.selectedTowerForUpgrade = clickedTower;
          }
        } else {
          game.selectedTowerForUpgrade = null;
        }
        return;
      }

      // é…ç½®ãƒ•ã‚§ãƒ¼ã‚ºï¼šã‚¿ãƒ¯ãƒ¼é…ç½®
      if (game.phase !== 'placement' || !game.selectedTower) return;

      if (gridX < 1 || gridX >= 4) return;

      const alreadyPlaced = game.towers.some(t => t.gridX === gridX && t.gridY === gridY);
      if (alreadyPlaced) return;

      const towerTypeDef = TOWER_TYPES[game.selectedTower];
      const mpCost = towerTypeDef.mpCost;

      // MPãƒã‚§ãƒƒã‚¯
      if (game.mp < mpCost) return;

      const levelStats = towerTypeDef.levels[0];

      game.towers.push({
        gridX: gridX,
        gridY: gridY,
        type: game.selectedTower,
        level: 0,
        lastAttackTime: 0,
        lastAttack: 0,
        hp: levelStats.hp,
        maxHp: levelStats.maxHp
      });

      game.mp -= mpCost;
      game.selectedTower = null;
      document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
      updateUI();
    });

    // ========================================
    // ã‚²ãƒ¼ãƒ é–‹å§‹
    // ========================================
    placeEnemyTowers(); // åˆæœŸãƒ¬ãƒ™ãƒ«ã®æ•µã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®
    updateUI();
    gameLoop();
  </script>
</body>
</html>
